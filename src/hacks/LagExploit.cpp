/*
 * LagExploit.cpp
 *
 *  Created on: May 7, 2017
 *      Author: nullifiedcat
 */

#include "LagExploit.hpp"

namespace hacks { namespace shared { namespace lagexploit {

CatVar toggle(CV_SWITCH, "removecond_toggle", "0", "Toggle Lag Exploit", "Toggle lag exploit (RemoveCond)");
CatVar key(CV_KEY, "removecond_key", "0", "RemoveCond Key");
CatVar lagMasterSwitch(CV_SWITCH, "removecond_master", "1", "Master Lag Exploit Switch", "Master switch for the lag exploit\nDisabling this disables everything else that uses remove conds");
CatVar lagValue(CV_INT, "removecond_value", "900", "RemoveCond Value", "Value of user cmds to spam with");
	
CatCommand do_lagexploit("removecond", "RemoveCond (for use in scripts)", []() {
	AddExploitTicks(6);
});

CatVar clear_fire(CV_SWITCH, "removecond_fire", "0", "Remove Fire");
CatVar clear_taunt(CV_SWITCH, "removecond_taunt", "0", "Remove Taunting");
CatVar clear_bleeding(CV_SWITCH, "removecond_bleeding", "0", "Remove Bleeding");
CatVar clear_stun(CV_SWITCH, "removecond_stun", "0", "Remove Stun");
CatVar instant_uncloak(CV_SWITCH, "instant_decloak", "0", "Insta Decloak", "Decloaks you on attack");
CatVar instant_rezoom(CV_SWITCH, "instant_rezoom", "0", "Instant rezoom", "Allows you to instantly zoom after you shoot\nGreat for precharging charged shots before you can fire again\nOccasionally fails");

CatCommand reset_command_number("debug_reset_cmd_number", "", []() {
	*(int*)((unsigned)g_IBaseClientState + offsets::lastoutgoingcommand()) = 1;
	INetChannel* ch = (INetChannel*)g_IEngine->GetNetChannelInfo();
	int& m_nOutSequenceNr = *(int*)((unsigned)ch + offsets::m_nOutSequenceNr());
	m_nOutSequenceNr = 1;
});

int exticks = 0;
void AddExploitTicks(int ticks) {
	exticks = max(ticks, exticks);
}
	
// Instant re-zoom storage vars
bool insRezoomDepressed = false;
bool insRezoomMain = false;
float instant_rezoom_tick = 0;
bool instant_rezoom_timer_active = false;
int instant_rezoom_timer_step = 0;


bool ExploitActive() {
	if (toggle) return true;
	if (exticks > 0) {
		return true;
	}
	if (g_IInputSystem->IsButtonDown((ButtonCode_t)((int)key))) {
		return true;
	}
	return false;
}

static CatVar mini_lag_exploit(CV_INT, "lagexploit_mini", "0", "Mini Lag Exploit");
static CatVar instant_weapon_switch(CV_SWITCH, "instant_weapon_switch", "0", "Instant weapon switch");
static CatVar infinite_packs(CV_SWITCH, "infinite_packs", "0", "Infinite Pickups", "Activate removecond when standing on pickups while having not full HP/Ammo");

void CreateMove() {
	if (CE_BAD(LOCAL_E)) return;
	if (exticks > 0) exticks--;
	
	// Pasted from kathook
	static int lastweapon = 0;
	if (instant_weapon_switch && lastweapon != g_pUserCmd->weaponselect) {
		AddExploitTicks(1);
	}
	lastweapon = g_pUserCmd->weaponselect;
	static bool flag = false;

	if (!exticks) {
		if (instant_uncloak && HasCondition<TFCond_Cloaked>(LOCAL_E)) {
			if (g_pUserCmd->buttons & (IN_ATTACK)) {
//				if (!flag) {
					AddExploitTicks(1);
					logging::Info("Uncloaking");
					flag = true;
//				}
			} else {
				flag = false;
			}
		}

		if (clear_fire && HasCondition<TFCond_OnFire>(LOCAL_E)) AddExploitTicks(3);
		if (clear_bleeding && HasCondition<TFCond_Bleeding>(LOCAL_E)) AddExploitTicks(3);
		if (clear_taunt && HasCondition<TFCond_Taunting>(LOCAL_E)) AddExploitTicks(3);
		if (clear_stun && HasCondition<TFCond_Dazed>(LOCAL_E)) AddExploitTicks(3);

		// Check if user settings allow Instant re-zoom 
		if (instant_rezoom) {
			// Is +attack is being used, set a holder var and wait untill it is depressed
			if (g_pUserCmd->buttons & IN_ATTACK && g_pLocalPlayer->bZoomed && !insRezoomMain) {
				insRezoomDepressed = true;
			// If +attack is not used while the holder var tells us it was depressed, then start running instant re-zoom
			} else if (!(g_pUserCmd->buttons & IN_ATTACK) && g_pLocalPlayer->bZoomed && insRezoomDepressed) {
				insRezoomDepressed = false;
				insRezoomMain = true;
			// Some instant recoom logic, its based on timers due to the way the lag exploit acts apon it.
			// If it would have been done better, I would do so but this works fine as is...
			} else if (insRezoomMain) {
				if (!instant_rezoom_timer_active) {
					//Setup
					instant_rezoom_timer_active = true;
					instant_rezoom_timer_step = 0;
					instant_rezoom_tick = 12;
				} else if (instant_rezoom_tick > 0 && instant_rezoom_timer_step == 0){
					instant_rezoom_tick--;
				} else if (instant_rezoom_timer_step == 0) {
					//Remove zoom cond
					AddExploitTicks(3);
					instant_rezoom_tick = 76;
					instant_rezoom_timer_step = 1;
				} else if (instant_rezoom_tick > 38 && instant_rezoom_timer_step == 1) {
					instant_rezoom_tick--;
				} else if (!g_pLocalPlayer->bZoomed && instant_rezoom_tick > 0) {
					//Re-Zoom
					instant_rezoom_timer_step == 2;
					instant_rezoom_tick--;
					if (!g_pLocalPlayer->bZoomed) g_pUserCmd->buttons |= IN_ATTACK2;
				} else {
					//Stop the function
					instant_rezoom_timer_active = false;
					insRezoomMain = false; 
				}
			}
		}
		
		// Infinite pickups (health and ammo)
		if (infinite_packs && CE_GOOD(LOCAL_E)) {
			ICollideable* p = RAW_ENT(LOCAL_E)->GetCollideable();
			const Vector& max1 = p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
			const Vector& min1 = p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
			for (int i = 1; i < entity_cache::max; i++) {
				CachedEntity* e = ENTITY(i);
				// CE_BAD is used to prevent removeconding on empty spaces where the item hasn't respawned
				// Class check to ensure entity is pickup item
				if (CE_BAD(e) || e->m_iClassID != CL_CLASS(CBaseAnimating)) {
					continue;
				}
				
				// Bounds check
				const Vector& max2 = p->OBBMaxs() + e->m_vecOrigin + Vector(8, 8, 8);
				const Vector& min2 = p->OBBMins() + e->m_vecOrigin - Vector(8, 8, 8);
				if (
				 (min1.x <= max2.x && max1.x >= min2.x) &&
				 (min1.y <= max2.y && max1.y >= min2.y) &&
				 (min1.z <= max2.z && max1.z >= min2.z) ) {
					//logging::Info("Collision with %d", i);
					
					// Lag for health
					if (LOCAL_E->m_iHealth < LOCAL_E->m_iMaxHealth && (e->m_ItemType == ITEM_HEALTH_SMALL || e->m_ItemType == ITEM_HEALTH_MEDIUM || e->m_ItemType == ITEM_HEALTH_LARGE) ) {
						AddExploitTicks(3);
					}
					// Lag for ammo / metal
					// TODO: Alternative to - LOCAL_E->m_iAmmo < LOCAL_E->m_iMaxAmmo
					// That is pseudocode but checking each weapon for ammo + engie for metal would be ideal
					if ((e->m_ItemType == ITEM_AMMO_SMALL || e->m_ItemType == ITEM_AMMO_MEDIUM || e->m_ItemType == ITEM_AMMO_LARGE) ) { 
						AddExploitTicks(3);
					}
				}
			}
		}
	}
	// More paste from kathook
	if (g_pUserCmd->buttons & (IN_ATTACK | IN_ATTACK2)) {
		flag = true;
	} else {
		flag = false;
	}

	// Previously was in GetUserCmd
	// Thanks Blackfire for helping me improve removecond!

	if (!g_pUserCmd) return;
	if (!g_pUserCmd->command_number) return;
	if (!lagMasterSwitch) return;
	int amount = int(lagValue);
	if (!ExploitActive()) {
		amount = int(mini_lag_exploit);
	} 
  

	if (!amount) return;
	// Modifying command_number and lastoutgoingcommand turned out to be useless

	//cmd->command_number += amount;
	//*(int*)((unsigned)g_IBaseClientState + offsets::lastoutgoingcommand()) += amount;

	INetChannel* ch = (INetChannel*)g_IEngine->GetNetChannelInfo();
	int& m_nOutSequenceNr = *(int*)((unsigned)ch + offsets::m_nOutSequenceNr());
	m_nOutSequenceNr += amount;

}

}}}
