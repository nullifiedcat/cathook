/*
 * LagExploit.cpp
 *
 *  Created on: May 7, 2017
 *      Author: nullifiedcat
 */

#include "common.hpp"

namespace hacks
{
namespace shared
{
namespace lagexploit
{

CatVar toggle(CV_SWITCH, "se_toggle", "0", "toggle", "Toggle sequence exploit");
CatVar shoot(CV_SWITCH, "se_shoot", "0", "Instant revvup/shoot",
             "Instant revvup/shoot two shots at once");

// SHOUTOUTS TO BLACKFIRE
CatVar doom(CV_SWITCH, "se_doom", "0", "Shoot 2+ shots at once",
            "See Center string on activation.");
CatVar razorback(CV_SWITCH, "se_antirazorback", "0", "Anti-Razorback",
                 "Stab through razorbacks");
CatVar stickyspam(CV_SWITCH, "se_stickyspam", "0", "Sticky spam",
                  "Allows Spam of stickies simply by holding Mouse1.");
CatVar cloak(CV_SWITCH, "se_cloak", "0", "Instant decloak/cloak", "");
CatVar cap(CV_SWITCH, "se_cap", "0", "Auto instant cap", "");
CatVar cart(CV_SWITCH, "se_cart", "0", "Farm cart points",
            "Automatically farm points by touching "
            "the cart (only works on attacking "
            "team)");
CatVar instant_weapon_switch(CV_SWITCH, "se_switch", "0",
                             "Instant weapon switch", "");
CatVar key(CV_KEY, "se_key", "0", "Sequence exploit key");
CatVar weaponswitch(CV_KEY, "se_switch_key", "0",
                    "Switch spam key (for gru) key");
CatVar delay1(CV_INT, "se_switch_delay1", "0",
              "Delay before switching to melee");
CatVar delay2(CV_INT, "se_switch_delay2", "0",
              "Delay before switching to Primary");
CatVar master_switch(CV_SWITCH, "se_master", "1", "Enable sequence exploit",
                     "Master switch for the sequence exploit\nDisabling this "
                     "disables everything else that uses it");
CatVar value(CV_INT, "se_value", "900", "Sequence exploit value",
             "Value of user cmds to spam with");

CatCommand do_lagexploit("se_do", "Sequence exploit (for use in scripts)",
                         []() { AddExploitTicks(6); });
int exticks           = 0;
const model_t *point  = nullptr;
const model_t *point2 = nullptr;
const model_t *point3 = nullptr;
const model_t *point4 = nullptr;
const model_t *point5 = nullptr;
void AddExploitTicks(int ticks)
{
    exticks = std::max(ticks, exticks);
}
bool active = false;
bool ExploitActive()
{
    if (toggle)
        return true;
    if (exticks > 0)
    {
        return true;
    }
    if (g_IInputSystem->IsButtonDown((ButtonCode_t)((int) key)))
    {
        return true;
    }
    if (active)
        return true;
    return false;
}

static CatVar infinite_packs(CV_SWITCH, "infinite_packs", "0",
                             "Infinite Pickups",
                             "Activate sequence exploit when standing on "
                             "pickups while having not full HP/Ammo");
float servertime, nextattack, nextattack2;
static int lastwep = 0;
void CreateMove()
{
    active = false;
    if (CE_BAD(LOCAL_E))
        return;
    if (!LOCAL_E->m_bAlivePlayer)
        return;
    if (exticks > 0)
        exticks--;

    if (!exticks)
    {
        // Infinite pickups (health and ammo)
        if (infinite_packs && CE_GOOD(LOCAL_E))
        {
            ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
            const Vector &max1 =
                p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            const Vector &min1 =
                p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            for (int i = 1; i < entity_cache::max; i++)
            {
                CachedEntity *e = ENTITY(i);
                // CE_BAD is used to prevent removeconding on empty spaces where
                // the item hasn't respawned Class check to ensure entity is
                // pickup item
                if (CE_BAD(e) || e->m_iClassID != CL_CLASS(CBaseAnimating))
                {
                    continue;
                }

                ICollideable *c = RAW_ENT(e)->GetCollideable();

                // Bounds check
                const Vector &max2 =
                    c->OBBMaxs() + e->m_vecOrigin + Vector(8, 8, 8);
                const Vector &min2 =
                    c->OBBMins() + e->m_vecOrigin - Vector(8, 8, 8);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    // logging::Info("Collision with %d", i);

                    // Lag for health
                    if (LOCAL_E->m_iHealth < LOCAL_E->m_iMaxHealth &&
                        (e->m_ItemType == ITEM_HEALTH_SMALL ||
                         e->m_ItemType == ITEM_HEALTH_MEDIUM ||
                         e->m_ItemType == ITEM_HEALTH_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                    // Lag for ammo / metal
                    // TODO: Alternative to - LOCAL_E->m_iAmmo <
                    // LOCAL_E->m_iMaxAmmo That is pseudocode but checking each
                    // weapon for ammo + engie for metal would be ideal
                    if (CE_INT(g_pLocalPlayer->weapon(), netvar.m_iAmmo) < 5 &&
                        (e->m_ItemType == ITEM_AMMO_SMALL ||
                         e->m_ItemType == ITEM_AMMO_MEDIUM ||
                         e->m_ItemType == ITEM_AMMO_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                }
            }
        }
    }

    // Previously was in GetUserCmd
    // Thanks Blackfire for helping me improve removecond!

    if (!g_pUserCmd)
        return;
    if (!g_pUserCmd->command_number)
        return;
    int amount = 0;
    for (int i = 1; i < HIGHEST_ENTITY; i++)
    {
        if (!point2)
        {
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            const char *model_name = g_IModelInfo->GetModelName(model);
            if (strstr("models/props_trainyard/bomb_cart.mdl", model_name))
                point2 = model;
        }
        if (!point3)
        {
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            const char *model_name = g_IModelInfo->GetModelName(model);
            if (strstr("models/props_2fort/trainwheel001.mdl", model_name))
                point3 = model;
        }
        if (!point4)
        {
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            const char *model_name = g_IModelInfo->GetModelName(model);
            if (strstr("models/custom/dirty_bomb_cart.mdl", model_name))
                point4 = model;
        }
        if (!point5)
        {
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            const char *model_name = g_IModelInfo->GetModelName(model);
            if (strstr("models/props_trainyard/bomb_cart_red.mdl", model_name))
                point5 = model;
        }
    }
    if (cart)
    {
        for (int i = 1; i < HIGHEST_ENTITY; i++)
        {
            if (!point2 && !point3 && !point4 && !point5)
                continue;
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            if (pEnt->m_iTeam == LOCAL_E->m_iTeam)
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            if (model == point2 || model == point3 || model == point4 ||
                model == point5)
            {
                if (!CE_GOOD(LOCAL_E))
                    continue;
                ICollideable *c = RAW_ENT(pEnt)->GetCollideable();
                ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
                const Vector &max1 =
                    p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &min1 =
                    p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &max2 =
                    c->OBBMaxs() + pEnt->m_vecOrigin + Vector(25, 25, 25);
                const Vector &min2 =
                    c->OBBMins() + pEnt->m_vecOrigin - Vector(25, 25, 25);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    amount = 50;
                }
            }
        }
    }
    if (!master_switch)
        return;
    if (weaponswitch.KeyDown())
    {
        static int aa = 0, bb = 0;
        if (aa > (int) delay1)
        {
            g_IEngine->ExecuteClientCmd("slot1");
            aa = 0;
        }
        if (bb > (int) delay1 + (int) delay2)
        {
            g_IEngine->ExecuteClientCmd("slot3");
            bb = 0;
        }
        aa++;
        bb++;
    }
    static bool bWasHolding = false;
    bool bIsHolding         = ((g_pUserCmd->buttons & IN_ATTACK) ||
                       (g_pUserCmd->buttons & IN_ATTACK2));

    if (cap)
    {
        for (int i = 1; i < HIGHEST_ENTITY; i++)
        {
            if (!point)
            {
                CachedEntity *pEnt = ENTITY(i);
                if (!CE_GOOD(pEnt))
                    continue;
                const model_t *model = RAW_ENT(pEnt)->GetModel();
                if (!model)
                    continue;
                const char *model_name = g_IModelInfo->GetModelName(model);
                if (strstr("models/props_gameplay/cap_point_base.mdl",
                           model_name))
                    point = model;
                else
                    continue;
            }
            if (!point)
                continue;
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            if (pEnt->m_iTeam == LOCAL_E->m_iTeam)
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            if (model == point)
            {
                if (!CE_GOOD(LOCAL_E))
                    continue;
                ICollideable *c = RAW_ENT(pEnt)->GetCollideable();
                ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
                const Vector &max1 =
                    p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &min1 =
                    p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &max2 =
                    c->OBBMaxs() + pEnt->m_vecOrigin + Vector(200, 200, 200);
                const Vector &min2 =
                    c->OBBMins() + pEnt->m_vecOrigin - Vector(200, 200, 200);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    amount = (int) value;
                }
            }
        }
    }
    if (cloak && shoot)
    {
        if (!(doom &&
              g_pLocalPlayer->weapon()->m_iClassID != CL_CLASS(CTFMinigun) &&
              !(g_pUserCmd->buttons & IN_ATTACK2)))
        {
            if ((g_pUserCmd->buttons & IN_ATTACK) && !bWasHolding &&
                HasCondition<TFCond_Cloaked>(LOCAL_E))
            {
                g_pUserCmd->buttons &= ~IN_ATTACK;
                g_pUserCmd->buttons |= IN_ATTACK2;
                amount = 2 * 90;
            }
            else if (CanShoot() && bIsHolding && !bWasHolding &&
                     g_pLocalPlayer->weapon()->m_iClassID !=
                         CL_CLASS(CTFFlareGun))
                amount = 1 * 90;
            else if (CanShoot() && bIsHolding && !bWasHolding &&
                     g_pLocalPlayer->weapon()->m_iClassID ==
                         CL_CLASS(CTFFlareGun))
                amount = 2 * 90;
            else if (bWasHolding && !bIsHolding)
                amount = 1 * 90;

            bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                          (g_pUserCmd->buttons & IN_ATTACK2);
        }
    }
    else if (!cloak)
    {
        if (shoot)
        {
            if (!(doom &&
                  g_pLocalPlayer->weapon()->m_iClassID !=
                      CL_CLASS(CTFMinigun) &&
                  !(g_pUserCmd->buttons & IN_ATTACK2)))
            {
                if (!g_pLocalPlayer->holding_sniper_rifle)
                {
                    if (CanShoot() && bIsHolding && !bWasHolding &&
                        g_pLocalPlayer->weapon()->m_iClassID !=
                            CL_CLASS(CTFFlareGun))
                        amount = 1 * 90;
                    else if (CanShoot() && bIsHolding && !bWasHolding &&
                             g_pLocalPlayer->weapon()->m_iClassID ==
                                 CL_CLASS(CTFFlareGun))
                        amount = 2 * 90;
                    else if (bWasHolding && !bIsHolding)
                        amount = 1 * 90;
                    bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                                  (g_pUserCmd->buttons & IN_ATTACK2);
                }
                else
                {
                    bIsHolding = (g_pUserCmd->buttons & IN_ATTACK);
                    if (CanShoot() && bIsHolding && !bWasHolding)
                        amount = 1 * 90;
                    else if (bWasHolding && !bIsHolding)
                        amount = 1 * 90;
                    bWasHolding = (g_pUserCmd->buttons & IN_ATTACK);
                }
            }
        }
    }
    else if (!shoot)
    {
        if (cloak)
        {
            if ((g_pUserCmd->buttons & IN_ATTACK2) && !bWasHolding &&
                !HasCondition<TFCond_Cloaked>(LOCAL_E))
            {
                amount = 1 * 90;
            }

            if ((g_pUserCmd->buttons & IN_ATTACK) && !bWasHolding &&
                HasCondition<TFCond_Cloaked>(LOCAL_E))
            {
                g_pUserCmd->buttons &= ~IN_ATTACK;
                g_pUserCmd->buttons |= IN_ATTACK2;
                amount = 2 * 90;
            }
            bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                          (g_pUserCmd->buttons & IN_ATTACK2);
        }
    }

    if (key.KeyDown() || exticks || toggle)
        amount = int(value);

    // Thanks Wheaties For help!
    if (stickyspam)
    {
        if (g_pLocalPlayer->weapon()->m_iClassID == (CL_CLASS(CTFCannon)) ||
            g_pLocalPlayer->weapon()->m_iClassID ==
                (CL_CLASS(CTFPipebombLauncher)))
        {
            static bool bSwitch = false;
            if ((g_pUserCmd->buttons & IN_ATTACK) && !bSwitch)
            {
                bSwitch = true;
            }
            else if (bSwitch)
            {
                amount = 1 * 50;
                g_pUserCmd->buttons &= ~IN_ATTACK;
                bSwitch = false;
            }
        }
    }
    if (instant_weapon_switch && !HasCondition<TFCond_Cloaked>(LOCAL_E))
    {
        if (lastwep != g_pLocalPlayer->weapon()->m_iClassID)
        {
            amount  = 2 * 90;
            lastwep = g_pLocalPlayer->weapon()->m_iClassID;
        }
    }
    // SHOUTOUTS TO BLACKFIRE
    if (doom || razorback)
    {
        static int i  = 0;
        static int i2 = 0;
        servertime =
            (float) (CE_INT(g_pLocalPlayer->entity, netvar.nTickBase)) *
            g_GlobalVars->interval_per_tick;
        if (!nextattack || !i ||
            g_pLocalPlayer->weapon()->m_iClassID != lastwep)
            nextattack =
                CE_FLOAT(g_pLocalPlayer->weapon(), netvar.flNextPrimaryAttack);
        if (!nextattack2 || !i ||
            g_pLocalPlayer->weapon()->m_iClassID != lastwep)
            nextattack2 = CE_FLOAT(g_pLocalPlayer->weapon(),
                                   netvar.flNextSecondaryAttack);
        if (servertime - nextattack > 75.0f)
            nextattack = servertime - 75.0f;
        if (servertime - nextattack2 > 75.0f)
            nextattack2 = servertime - 75.0f;
        if (doom && servertime - nextattack > 0.0f &&
            g_pUserCmd->buttons & IN_ATTACK)
        {
            if (!i)
                i = ((int) servertime - (int) nextattack);
            amount = i * 66;
            if (CE_INT(g_pLocalPlayer->weapon(), netvar.m_iClip1) == 0)
                g_pUserCmd->buttons &= ~IN_ATTACK;
        }
        if (doom && servertime - nextattack2 > 0.0f &&
            g_pUserCmd->buttons & IN_ATTACK2 &&
            g_pLocalPlayer->weapon()->m_iClassID != CL_CLASS(CTFMinigun))
        {
            if (!i2)
                i2 = ((int) servertime - (int) nextattack2);
            amount = i2 * 66;
            if (CE_INT(g_pLocalPlayer->weapon(), netvar.m_iClip2) == 0)
                g_pUserCmd->buttons &= ~IN_ATTACK2;
        }
        if (razorback && servertime - nextattack > 3.0f &&
            (g_pUserCmd->buttons & IN_ATTACK ||
             g_pUserCmd->buttons & IN_ATTACK2))
        {
            if (g_pLocalPlayer->weapon()->m_iClassID == CL_CLASS(CTFKnife))
            {
                if (!i)
                    i = 3;
                amount = i * 66;
                g_pUserCmd->buttons |= IN_ATTACK;
            }
        }
        if (i)
            i--;
        lastwep = g_pLocalPlayer->weapon()->m_iClassID;
    }
    if (!amount)
        return;
    active = true;
    /*g_pUserCmd->command_number += amount;
    g_pUserCmd->hasbeenpredicted = true;
    *(int *) ((unsigned) g_IBaseClientState + offsets::lastoutgoingcommand()) +=
        amount;*/
    INetChannel *ch = (INetChannel *) g_IEngine->GetNetChannelInfo();
    int &m_nOutSequenceNr =
        *(int *) ((unsigned) ch + offsets::m_nOutSequenceNr());
    m_nOutSequenceNr += amount;
    //*bSendPackets = true;
}
void Draw()
{
#if ENABLE_VISUALS == 1
    if (doom && (servertime - nextattack > 0.0f || servertime - nextattack2))
    {
        auto amount  = (int) servertime - (int) nextattack;
        auto amount2 = (int) servertime - (int) nextattack2;
        if (amount > 0.0f)
            AddCenterString(format("Fireable Primary amount: ", amount),
                            colors::orange);
        if (amount2 > 0.0f)
            AddCenterString(format("Fireable Secondary amount: ", amount2),
                            colors::orange);
    }
    if (razorback)
        if (servertime - nextattack > 3.0f)
        {
            AddCenterString(format("Can Stab through Razorback"),
                            colors::green);
        }
        else if (servertime - nextattack < 3.0f)
            AddCenterString(format("Can't Stab through Razorback"),
                            colors::red);

#endif
}
}
}
}
