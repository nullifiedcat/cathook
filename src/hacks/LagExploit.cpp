/*
 * LagExploit.cpp
 *
 *  Created on: May 7, 2017
 *      Author: nullifiedcat
 */

#include "common.hpp"

namespace hacks
{
namespace shared
{
namespace lagexploit
{

CatVar toggle(CV_SWITCH, "se_toggle", "0", "Toggle sequence exploit");
CatVar key(CV_KEY, "se_key", "0", "Sequence exploit key");
CatVar master_switch(CV_SWITCH, "se_master", "1", "Enable sequence exploit",
                     "Master switch for the sequence exploit\nDisabling this "
                     "disables everything else that uses it");
CatVar value(CV_INT, "se_value", "900", "Sequence exploit value",
             "Value of user cmds to spam with");

CatCommand do_lagexploit("se_do", "Sequence exploit (for use in scripts)",
                         []() { AddExploitTicks(6); });

int exticks = 0;
void AddExploitTicks(int ticks)
{
    exticks = std::max(ticks, exticks);
}

bool ExploitActive()
{
    if (toggle)
        return true;
    if (exticks > 0)
    {
        return true;
    }
    if (g_IInputSystem->IsButtonDown((ButtonCode_t)((int) key)))
    {
        return true;
    }
    return false;
}

static CatVar infinite_packs(CV_SWITCH, "infinite_packs", "0",
                             "Infinite Pickups",
                             "Activate sequence exploit when standing on "
                             "pickups while having not full HP/Ammo");

void CreateMove()
{
    if (CE_BAD(LOCAL_E))
        return;
    if (exticks > 0)
        exticks--;

    if (!exticks)
    {
        // Infinite pickups (health and ammo)
        if (infinite_packs && CE_GOOD(LOCAL_E))
        {
            ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
            const Vector &max1 =
                p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            const Vector &min1 =
                p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            for (int i = 1; i < entity_cache::max; i++)
            {
                CachedEntity *e = ENTITY(i);
                // CE_BAD is used to prevent removeconding on empty spaces where
                // the item hasn't respawned Class check to ensure entity is
                // pickup item
                if (CE_BAD(e) || e->m_iClassID != CL_CLASS(CBaseAnimating))
                {
                    continue;
                }

                ICollideable *c = RAW_ENT(e)->GetCollideable();

                // Bounds check
                const Vector &max2 =
                    c->OBBMaxs() + e->m_vecOrigin + Vector(8, 8, 8);
                const Vector &min2 =
                    c->OBBMins() + e->m_vecOrigin - Vector(8, 8, 8);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    // logging::Info("Collision with %d", i);

                    // Lag for health
                    if (LOCAL_E->m_iHealth < LOCAL_E->m_iMaxHealth &&
                        (e->m_ItemType == ITEM_HEALTH_SMALL ||
                         e->m_ItemType == ITEM_HEALTH_MEDIUM ||
                         e->m_ItemType == ITEM_HEALTH_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                    // Lag for ammo / metal
                    // TODO: Alternative to - LOCAL_E->m_iAmmo <
                    // LOCAL_E->m_iMaxAmmo That is pseudocode but checking each
                    // weapon for ammo + engie for metal would be ideal
                    if ((e->m_ItemType == ITEM_AMMO_SMALL ||
                         e->m_ItemType == ITEM_AMMO_MEDIUM ||
                         e->m_ItemType == ITEM_AMMO_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                }
            }
        }
    }

    // Previously was in GetUserCmd
    // Thanks Blackfire for helping me improve removecond!

    if (!g_pUserCmd)
        return;
    if (!g_pUserCmd->command_number)
        return;
    if (!master_switch)
        return;
    int amount = 0;
    if (key.KeyDown())
        amount = int(value);

    if (!amount)
        return;
    // Modifying command_number and lastoutgoingcommand turned out to be useless

    // cmd->command_number += amount;
    //*(int*)((unsigned)g_IBaseClientState + offsets::lastoutgoingcommand()) +=
    // amount;

    INetChannel *ch = (INetChannel *) g_IEngine->GetNetChannelInfo();
    int &m_nOutSequenceNr =
        *(int *) ((unsigned) ch + offsets::m_nOutSequenceNr());
    m_nOutSequenceNr += amount;
}
}
}
}
